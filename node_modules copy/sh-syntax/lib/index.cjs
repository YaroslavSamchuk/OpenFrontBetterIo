'use strict';

var fs = require('node:fs/promises');
var path = require('node:path');
var node_url = require('node:url');
var node_crypto = require('node:crypto');
var _fs = require('node:fs');
var node_perf_hooks = require('node:perf_hooks');
require('../vendors/wasm_exec.cjs');

var _a, _b, _c;
(_a = globalThis.fs) != null ? _a : globalThis.fs = _fs;
(_b = globalThis.crypto) != null ? _b : globalThis.crypto = {
  // @ts-expect-error -- incompatible types
  getRandomValues: node_crypto.randomFillSync
};
(_c = globalThis.performance) != null ? _c : globalThis.performance = node_perf_hooks.performance;

const LangVariant = {
  /**
   * LangBash corresponds to the GNU Bash language, as described in its manual
   * at https://www.gnu.org/software/bash/manual/bash.html.
   *
   * We currently follow Bash version 5.2.
   *
   * Its string representation is "bash".
   */
  LangBash: 0,
  /**
   * LangPOSIX corresponds to the POSIX Shell language, as described at
   * https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html.
   *
   * Its string representation is "posix" or "sh".
   */
  LangPOSIX: 1,
  /**
   * LangMirBSDKorn corresponds to the MirBSD Korn Shell, also known as mksh, as
   * described at http://www.mirbsd.org/htman/i386/man1/mksh.htm. Note that it
   * shares some features with Bash, due to the shared ancestry that is ksh.
   *
   * We currently follow mksh version 59.
   *
   * Its string representation is "mksh".
   */
  LangMirBSDKorn: 2,
  /**
   * LangBats corresponds to the Bash Automated Testing System language, as
   * described at https://github.com/bats-core/bats-core. Note that it's just a
   * small extension of the Bash language.
   *
   * Its string representation is "bats".
   */
  LangBats: 3,
  /**
   * LangAuto corresponds to automatic language detection, commonly used by
   * end-user applications like shfmt, which can guess a file's language variant
   * given its filename or shebang.
   *
   * At this time, [Variant] does not support LangAuto.
   */
  LangAuto: 4
};

var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
class ParseError extends Error {
  constructor({ Filename, Incomplete, Text, Pos }) {
    super(Text);
    __publicField(this, "Filename");
    __publicField(this, "Incomplete");
    __publicField(this, "Text");
    __publicField(this, "Pos");
    this.Filename = Filename;
    this.Incomplete = Incomplete;
    this.Text = Text;
    this.Pos = Pos;
  }
}
let encoder;
let decoder;
const getProcessor = (getWasm) => {
  let wasmBufferSource;
  let wasmBufferSourcePromise;
  encoder != null ? encoder : encoder = new TextEncoder();
  decoder != null ? decoder : decoder = new TextDecoder();
  function processor(_0) {
    return __async(this, arguments, function* (textOrAst, {
      filepath,
      print = false,
      originalText,
      keepComments = true,
      variant = LangVariant.LangBash,
      stopAt = "",
      recoverErrors = 0,
      useTabs = false,
      tabWidth = 2,
      indent = useTabs ? 0 : tabWidth,
      binaryNextLine = true,
      switchCaseIndent = true,
      spaceRedirects = true,
      // eslint-disable-next-line sonarjs/deprecation
      keepPadding = false,
      minify = false,
      singleLine = false,
      functionNextLine = false
    } = {}) {
      if (!wasmBufferSource && !wasmBufferSourcePromise && getWasm.length === 0) {
        wasmBufferSourcePromise = Promise.resolve(
          getWasm()
        ).then(
          (source) => (
            /* istanbul ignore next -- @preserve */
            "arrayBuffer" in source ? source.arrayBuffer() : source
          )
        );
      }
      if (wasmBufferSourcePromise) {
        wasmBufferSource = yield wasmBufferSourcePromise;
      }
      if (typeof textOrAst !== "string" && !print) {
        print = true;
        if (originalText == null) {
          throw new TypeError(
            "`originalText` is required for now, hope we will find better solution later"
          );
        }
      }
      const go = new Go();
      const wasm = getWasm.length === 0 ? yield WebAssembly.instantiate(
        wasmBufferSource,
        go.importObject
      ) : {
        instance: yield getWasm(
          go.importObject
        )
      };
      void go.run(wasm.instance);
      const { memory, wasmAlloc, wasmFree, process } = wasm.instance.exports;
      const filePath = encoder.encode(filepath);
      const text = encoder.encode(originalText || textOrAst);
      const uStopAt = encoder.encode(stopAt);
      const filePathPointer = wasmAlloc(filePath.byteLength);
      new Uint8Array(memory.buffer).set(filePath, filePathPointer);
      const textPointer = wasmAlloc(text.byteLength);
      new Uint8Array(memory.buffer).set(text, textPointer);
      const stopAtPointer = wasmAlloc(uStopAt.byteLength);
      new Uint8Array(memory.buffer).set(uStopAt, stopAtPointer);
      const resultPointer = process(
        filePathPointer,
        filePath.byteLength,
        filePath.byteLength,
        textPointer,
        text.byteLength,
        text.byteLength,
        print,
        keepComments,
        variant,
        stopAtPointer,
        uStopAt.byteLength,
        uStopAt.byteLength,
        recoverErrors,
        indent,
        binaryNextLine,
        switchCaseIndent,
        spaceRedirects,
        keepPadding,
        minify,
        singleLine,
        functionNextLine
      );
      wasmFree(filePathPointer);
      wasmFree(textPointer);
      wasmFree(stopAtPointer);
      const result = new Uint8Array(memory.buffer).subarray(resultPointer);
      const end = result.indexOf(0);
      const string = decoder.decode(result.subarray(0, end));
      /* istanbul ignore if -- @preserve */
      if (!string.startsWith('{"') || !string.endsWith("}")) {
        throw new ParseError({
          Filename: filepath,
          Incomplete: true,
          Text: string
        });
      }
      const {
        file,
        text: processedText,
        parseError,
        message
      } = JSON.parse(string);
      if (parseError || message) {
        /* istanbul ignore next -- @preserve */
        throw parseError == null ? new SyntaxError(message) : new ParseError(parseError);
      }
      return print ? processedText : file;
    });
  }
  return processor;
};

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
const import_meta = {};
/* istanbul ignore next -- @preserve */
const _dirname = import_meta.url ? path.dirname(node_url.fileURLToPath(import_meta.url)) : __dirname;
const processor = getProcessor(
  () => fs.readFile(path.resolve(_dirname, "../main.wasm"))
);
const parse = (text, options) => processor(text, options);
function print(textOrAst, options) {
  if (typeof textOrAst === "string") {
    return processor(textOrAst, __spreadProps(__spreadValues({}, options), {
      print: true
    }));
  }
  return processor(textOrAst, options);
}

exports.LangVariant = LangVariant;
exports.ParseError = ParseError;
exports.getProcessor = getProcessor;
exports.parse = parse;
exports.print = print;
exports.processor = processor;
