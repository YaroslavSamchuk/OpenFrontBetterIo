import { awsExpectUnion as __expectUnion, loadRestJsonErrorCode, parseJsonBody as parseBody, parseJsonErrorBody as parseErrorBody, } from "@aws-sdk/core";
import { HttpRequest as __HttpRequest } from "@smithy/protocol-http";
import { _json, collectBody, decorateServiceException as __decorateServiceException, expectBoolean as __expectBoolean, expectLong as __expectLong, expectNonNull as __expectNonNull, expectNumber as __expectNumber, expectString as __expectString, limitedParseDouble as __limitedParseDouble, parseEpochTimestamp as __parseEpochTimestamp, take, withBaseException, } from "@smithy/smithy-client";
import { v4 as generateIdempotencyToken } from "uuid";
import { ActiveSessionsExceededException, ActiveStatementsExceededException, BatchExecuteStatementException, DatabaseConnectionException, ExecuteStatementException, InternalServerException, QueryTimeoutException, ResourceNotFoundException, ValidationException, } from "../models/models_0";
import { RedshiftDataServiceException as __BaseException } from "../models/RedshiftDataServiceException";
export const se_BatchExecuteStatementCommand = async (input, context) => {
    const headers = sharedHeaders("BatchExecuteStatement");
    let body;
    body = JSON.stringify(se_BatchExecuteStatementInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CancelStatementCommand = async (input, context) => {
    const headers = sharedHeaders("CancelStatement");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeStatementCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeStatement");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeTableCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeTable");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ExecuteStatementCommand = async (input, context) => {
    const headers = sharedHeaders("ExecuteStatement");
    let body;
    body = JSON.stringify(se_ExecuteStatementInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetStatementResultCommand = async (input, context) => {
    const headers = sharedHeaders("GetStatementResult");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetStatementResultV2Command = async (input, context) => {
    const headers = sharedHeaders("GetStatementResultV2");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListDatabasesCommand = async (input, context) => {
    const headers = sharedHeaders("ListDatabases");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListSchemasCommand = async (input, context) => {
    const headers = sharedHeaders("ListSchemas");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListStatementsCommand = async (input, context) => {
    const headers = sharedHeaders("ListStatements");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListTablesCommand = async (input, context) => {
    const headers = sharedHeaders("ListTables");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const de_BatchExecuteStatementCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_BatchExecuteStatementOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CancelStatementCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeStatementCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeStatementResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeTableCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ExecuteStatementCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ExecuteStatementOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetStatementResultCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetStatementResultResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetStatementResultV2Command = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ListDatabasesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ListSchemasCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ListStatementsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListStatementsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ListTablesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ActiveSessionsExceededException":
        case "com.amazonaws.redshiftdata#ActiveSessionsExceededException":
            throw await de_ActiveSessionsExceededExceptionRes(parsedOutput, context);
        case "ActiveStatementsExceededException":
        case "com.amazonaws.redshiftdata#ActiveStatementsExceededException":
            throw await de_ActiveStatementsExceededExceptionRes(parsedOutput, context);
        case "BatchExecuteStatementException":
        case "com.amazonaws.redshiftdata#BatchExecuteStatementException":
            throw await de_BatchExecuteStatementExceptionRes(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.redshiftdata#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.redshiftdata#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        case "DatabaseConnectionException":
        case "com.amazonaws.redshiftdata#DatabaseConnectionException":
            throw await de_DatabaseConnectionExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.redshiftdata#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "QueryTimeoutException":
        case "com.amazonaws.redshiftdata#QueryTimeoutException":
            throw await de_QueryTimeoutExceptionRes(parsedOutput, context);
        case "ExecuteStatementException":
        case "com.amazonaws.redshiftdata#ExecuteStatementException":
            throw await de_ExecuteStatementExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ActiveSessionsExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new ActiveSessionsExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ActiveStatementsExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new ActiveStatementsExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_BatchExecuteStatementExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new BatchExecuteStatementException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DatabaseConnectionExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new DatabaseConnectionException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ExecuteStatementExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new ExecuteStatementException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InternalServerExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new InternalServerException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_QueryTimeoutExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new QueryTimeoutException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ResourceNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new ResourceNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ValidationExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new ValidationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const se_BatchExecuteStatementInput = (input, context) => {
    return take(input, {
        ClientToken: [true, (_) => _ ?? generateIdempotencyToken()],
        ClusterIdentifier: [],
        Database: [],
        DbUser: [],
        ResultFormat: [],
        SecretArn: [],
        SessionId: [],
        SessionKeepAliveSeconds: [],
        Sqls: _json,
        StatementName: [],
        WithEvent: [],
        WorkgroupName: [],
    });
};
const se_ExecuteStatementInput = (input, context) => {
    return take(input, {
        ClientToken: [true, (_) => _ ?? generateIdempotencyToken()],
        ClusterIdentifier: [],
        Database: [],
        DbUser: [],
        Parameters: _json,
        ResultFormat: [],
        SecretArn: [],
        SessionId: [],
        SessionKeepAliveSeconds: [],
        Sql: [],
        StatementName: [],
        WithEvent: [],
        WorkgroupName: [],
    });
};
const de_BatchExecuteStatementOutput = (output, context) => {
    return take(output, {
        ClusterIdentifier: __expectString,
        CreatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Database: __expectString,
        DbGroups: _json,
        DbUser: __expectString,
        Id: __expectString,
        SecretArn: __expectString,
        SessionId: __expectString,
        WorkgroupName: __expectString,
    });
};
const de_DescribeStatementResponse = (output, context) => {
    return take(output, {
        ClusterIdentifier: __expectString,
        CreatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Database: __expectString,
        DbUser: __expectString,
        Duration: __expectLong,
        Error: __expectString,
        HasResultSet: __expectBoolean,
        Id: __expectString,
        QueryParameters: _json,
        QueryString: __expectString,
        RedshiftPid: __expectLong,
        RedshiftQueryId: __expectLong,
        ResultFormat: __expectString,
        ResultRows: __expectLong,
        ResultSize: __expectLong,
        SecretArn: __expectString,
        SessionId: __expectString,
        Status: __expectString,
        SubStatements: (_) => de_SubStatementList(_, context),
        UpdatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        WorkgroupName: __expectString,
    });
};
const de_ExecuteStatementOutput = (output, context) => {
    return take(output, {
        ClusterIdentifier: __expectString,
        CreatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Database: __expectString,
        DbGroups: _json,
        DbUser: __expectString,
        Id: __expectString,
        SecretArn: __expectString,
        SessionId: __expectString,
        WorkgroupName: __expectString,
    });
};
const de_Field = (output, context) => {
    if (output.blobValue != null) {
        return {
            blobValue: context.base64Decoder(output.blobValue),
        };
    }
    if (__expectBoolean(output.booleanValue) !== undefined) {
        return { booleanValue: __expectBoolean(output.booleanValue) };
    }
    if (__limitedParseDouble(output.doubleValue) !== undefined) {
        return { doubleValue: __limitedParseDouble(output.doubleValue) };
    }
    if (__expectBoolean(output.isNull) !== undefined) {
        return { isNull: __expectBoolean(output.isNull) };
    }
    if (__expectLong(output.longValue) !== undefined) {
        return { longValue: __expectLong(output.longValue) };
    }
    if (__expectString(output.stringValue) !== undefined) {
        return { stringValue: __expectString(output.stringValue) };
    }
    return { $unknown: Object.entries(output)[0] };
};
const de_FieldList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Field(__expectUnion(entry), context);
    });
    return retVal;
};
const de_GetStatementResultResponse = (output, context) => {
    return take(output, {
        ColumnMetadata: _json,
        NextToken: __expectString,
        Records: (_) => de_SqlRecords(_, context),
        TotalNumRows: __expectLong,
    });
};
const de_ListStatementsResponse = (output, context) => {
    return take(output, {
        NextToken: __expectString,
        Statements: (_) => de_StatementList(_, context),
    });
};
const de_SqlRecords = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_FieldList(entry, context);
    });
    return retVal;
};
const de_StatementData = (output, context) => {
    return take(output, {
        CreatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Id: __expectString,
        IsBatchStatement: __expectBoolean,
        QueryParameters: _json,
        QueryString: __expectString,
        QueryStrings: _json,
        ResultFormat: __expectString,
        SecretArn: __expectString,
        SessionId: __expectString,
        StatementName: __expectString,
        Status: __expectString,
        UpdatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
};
const de_StatementList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_StatementData(entry, context);
    });
    return retVal;
};
const de_SubStatementData = (output, context) => {
    return take(output, {
        CreatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Duration: __expectLong,
        Error: __expectString,
        HasResultSet: __expectBoolean,
        Id: __expectString,
        QueryString: __expectString,
        RedshiftQueryId: __expectLong,
        ResultRows: __expectLong,
        ResultSize: __expectLong,
        Status: __expectString,
        UpdatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
};
const de_SubStatementList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SubStatementData(entry, context);
    });
    return retVal;
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const throwDefaultError = withBaseException(__BaseException);
const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
        headers,
    };
    if (resolvedHostname !== undefined) {
        contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
        contents.body = body;
    }
    return new __HttpRequest(contents);
};
function sharedHeaders(operation) {
    return {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": `RedshiftData.${operation}`,
    };
}
